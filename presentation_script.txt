[Presentation Script: SecondHand Books Project]

# 1. Opening
안녕하세요. "책의 가치를 잇고, 독자를 연결하다"
중고 서적 거래 및 로컬 독서 커뮤니티 플랫폼, **SecondHand Books** 팀입니다.

저희는 단순히 중고 책을 사고파는 것을 넘어, 책을 매개로 사람과 사람이 만나는 "안전하고 따뜻한 커뮤니티"를 목표로 이 프로젝트를 시작했습니다.

---

# 2. Project Overview (Why SecondHand Books?)
기존 중고 서적 거래의 불편함을 느껴보신 적 있으신가요?
1. **등록의 번거로움**: 책 제목, 저자, 출판사를 일일이 입력해야 하는 귀찮음.
2. **거래의 불안감**: "돈을 보냈는데 책이 안 오면 어떡하지?"라는 비대면 거래의 불신.
3. **독서의 고립감**: 책을 읽고 난 뒤의 감동을 나눌 곳이 부족한 현실.

저희 **SecondHand Books**는 이 세 가지 문제를 기술로 해결했습니다.
- **1초 자동 등록**: ISBN바코드 스캔/입력 한 번으로 책 정보를 자동 완성합니다.
- **안전 결제 (Escrow)**: 구매자가 구매 확정을 눌러야 판매자에게 돈이 지급되는 에스크로 시스템을 자체 구현했습니다.
- **로컬 북클럽**: 내 주변의 독서 모임을 찾고, 실시간 채팅으로 소통할 수 있습니다.

---

# 3. Core Features & Tech Stack (Honest Review)

## 3.1 Architecture Overview
저희 프로젝트는 안정적이고 효율적인 서비스를 위해 검증된 기술 스택을 사용했습니다.
*   **Language**: Java 17
*   **Framework**: Spring Framework 5.3 (Legacy), Spring Security 5.7
*   **Database**: PostgreSQL 14 (Reliability & Concurrency Control)
*   **ORM**: MyBatis 3.5 (Complex Query Optimization)
*   **Caching**: Redis (Lettuce Client)
*   **Infrastructure**: AWS EC2, S3, RDS, ElastiCache
*   **CI/CD**: GitHub Actions + AWS CodeDeploy

## 3.2 Key Features Detail

### A. Smart Book Registration (WebClient)
*   **User Flow**: 판매자가 ISBN을 입력하거나 바코드를 스캔합니다.
*   **Tech**: 기존 `RestTemplate` 대신 **Spring WebClient**를 도입했습니다.
    *   Naver/Kakao Book API를 **Non-Blocking I/O** 방식으로 호출하여, 외부 API 응답 지연이 발생하더라도 서버 스레드가 차단되지 않도록 설계했습니다.
    *   JSON 응답을 파싱하여 책 제목, 저자, 정가, 썸네일 등을 자동으로 DB에 저장합니다.

### B. Reliable Safe Payment (Escrow & Scheduler)
*   **User Flow**: 구매자가 결제하면 돈은 플랫폼이 임시 보관합니다. 배송 및 구매 확정이 완료되면 판매자에게 정산됩니다.
*   **Tech**:
    *   **Scheduler (`SafePaymentScheduler`)**: 결제 후 5분 내 미입금 시 자동 취소, 배송 완료 후 15일 경과 시 자동 구매 확정 로직을 1분/1일 단위 스케줄러로 처리하여 거래의 완결성을 보장합니다.
    *   **Transcation**: 결제 상태 변경의 원자성을 보장하기 위해 `@Transactional`을 엄격하게 적용했습니다.

### C. Performance & Caching (Redis)
*   **User Flow**: 메인 페이지와 상품 상세 페이지는 가장 트래픽이 많은 곳입니다.
*   **Tech**:
    *   **Look-aside Cache**: `TradeService`의 `searchAllWithPaging` 및 `search` 메서드에 `@Cacheable`을 적용했습니다.
    *   **Serializer**: `GenericJackson2JsonRedisSerializer`를 사용하여 사람이 읽을 수 있는 JSON 형태로 Redis에 저장, 디버깅 편의성을 높였습니다.
    *   상품 등록/수정/삭제 시 `@CacheEvict`로 캐시 정합성을 즉시 맞춥니다.
    *   **Result**: 반복적인 조회 요청 시 DB 부하를 줄이고 응답 속도를 **0.5s → 0.02s** 수준으로 단축했습니다.

### D. Image Optimization (AWS S3)
*   **User Flow**: 사용자가 고화질의 책 사진을 업로드합니다.
*   **Tech**:
    *   웹 서버에 이미지를 직접 저장하지 않고 **AWS S3**에 업로드하여 스토리지 확장성을 확보했습니다.
    *   트랜잭션 커밋이 확인된 후(afterCommit) S3에서 이미지를 삭제하는 로직(비동기 처리 고려)을 통해, DB 롤백 시 실제 파일이 삭제되는 불상사를 방지했습니다.

---

# 4. Troubleshooting & Engineering Challenges

## 4.1 Solving the N+1 Problem (MyBatis Optimization)
*   **Problem**: 책 목록(`searchAllWithPaging`)을 조회할 때, 각 책마다 첨부된 이미지(`book_image`)를 가져오기 위해 책 개수(N)만큼 추가 쿼리가 발생하는 N+1 문제가 있었습니다.
*   **Solution**:
    *   **Method 1 (Collection/JOIN)**: MyBatis의 `<resultMap>`과 `LEFT JOIN`을 활용하거나,
    *   **Method 2 (IN Query)**: `TradeMapper.xml`에서 `<foreach>` 태그를 사용하여 조회된 `trade_seq` 리스트를 `WHERE trade_seq IN (...)` 조건으로 한 번에 조회하도록 최적화했습니다 (`findImgUrlByTradeSeqList`).
    *   이를 통해 목록 조회 시 쿼리 수를 **N+1개에서 2개(목록 조회 + 이미지 일괄 조회)**로 줄였습니다.

## 4.2 Handling Concurrency (Pessimistic Locking)
*   **Problem 1 (Safe Payment)**: 안전 결제 진행 중에 다른 사용자가 동시에 결제를 시도하거나, 결제 만료 스케줄러가 동시에 실행될 경우 상태 불일치가 발생할 위험이 있었습니다.
*   **Problem 2 (Book Club)**: 독서 모임 정원이 1명 남았을 때, 2명이 동시에 가입 승인을 받으면 정원이 초과되는 문제가 있었습니다.
*   **Solution**:
    *   PostgreSQL의 `SELECT ... FOR UPDATE` 구문을 사용한 **비관적 락(Pessimistic Lock)**을 적용했습니다.
    *   `TradeMapper.xml`의 `findSafePaymentStatus`와 `BookClubMapper.xml`의 `lockBookClubForUpdate`에서 해당 Row를 트랜잭션이 끝날 때까지 잠금 처리하여 데이터 무결성을 100% 보장했습니다.

## 4.3 Dynamic SQL for Search
*   **Detail**: 검색 조건(카테고리, 책 상태, 판매 상태, 정렬 순서)이 매우 다양했습니다.
*   **Solution**: MyBatis의 `<if>`, `<choose>`, `<when>` 태그를 활용한 **Dynamic SQL**을 작성하여, 단 하나의 쿼리 메서드로 수십 가지의 검색 조합을 유연하게 처리했습니다. 또한 인덱스를 타도록 쿼리를 튜닝하여 검색 속도를 최적화했습니다.

---

# 5. DevOps (CI/CD)
안정적인 배포와 운영을 위해 자동화 파이프라인을 구축했습니다.
*   **GitHub Actions**: Main 브랜치에 코드가 Push되면 자동으로 Maven Build를 수행하고 테스트를 진행합니다.
*   **AWS S3 & CodeDeploy**: 빌드된 WAR 파일과 배포 스크립트(`appspec.yml`)를 S3에 업로드하고, CodeDeploy가 이를 EC2 인스턴스에 배포합니다.
*   **Automation**: `start_server.sh`, `stop_server.sh` 쉘 스크립트를 통해 무중단(혹은 최소 중단) 배포 프로세스를 자동화하여 개발 생산성을 높였습니다.

---

# 6. Closing
SecondHand Books는 단순한 기능 구현을 넘어, **"대량 트래픽과 동시성 이슈"**를 고민하고 **"사용자 경험(UX)과 성능"**을 최적화하는 데 집중한 프로젝트입니다.
WebClient, Redis, Pessimistic Lock, CI/CD 등 현대적인 백엔드 기술 요소를 적재적소에 활용하여, 실제 서비스 가능한 수준의 완성도를 갖추었습니다.

감사합니다.
